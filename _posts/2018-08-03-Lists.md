---
title: 2. Lists
categories:
- CS 61B
tags:
- CS 61B
- Lists
---

# The Mystery of the Walrus

Does the change to **b** affect **a**?

```java
Walrus a = new Walrus(1000, 8.3);
Walrus b;
b = a;
b.weight = 5;
System.out.println(a);
System.out.println(b);
```

Does the change to **x** affect **y**?

```java
int x = 5;
int y;
y = x;
x = 2;
System.out.println("x is: " + x);
System.out.println("y is: " + y);
```

<!-- more -->

Answer:

```
a -> weight: 5, tusk size: 8.30
b -> weight: 5, tusk size: 8.30
x -> 2
y -> 5
```

### Bits

All information in computer is stored in **memory** as a sequence of **ones** and **zeros**. Some examples:

* 72 is often stored as 01001000
* 205.75 is often stored as 01000011 01001101 11000000 00000000
* The letter H is often stored as 01001000
* The true value is often stored as 00000001

Notice that both `72` and `H` are stored as `01001000`. How does a piece of Java code know how to interpret `01001000`. The answer is through `types`.

In Java, there are 8 primitive types: byte, short, int, long, float, double, boolean, and char.

##### Declaring a Variable(Simplified)

For example, if you declared `int x` and `double y`, then Java might decide to use bits **352** through **384** of your computer's memory to store **x**, and bits **20800** through **20864** to store **y**. 

In addition to setting aside memory, the Java interpreter also creates an entry in an internal table that maps each variable name to the location of the first bit in the box. So the interpreter will then record that **int x** starts at bit **352** and **y** starts at bit **20800**.

### :star: The Golden Rule of Equals (GRoE)

When you write `y = x`, Java interpreter copy the bits from **x** to **y**.

##### Reference Types

There are 8 primitive types: byte, short, int, long, float, double, boolean, char.

Everything else, including arrays, is not a primitive type but rather a `reference type`.

##### Object Instantiation

We create a Walrus using `new Walrus(1000, 8.3);`, then we end up with a Walrus consisting of two boxes of 32 and 64 bits respectively. 

(In real implementations of the Java programming language, there is actually some additional overhead for any object, so a Walrus takes somewhat more than 96 bits.)

##### :star: Reference Variable Declaration

When we **declare** a variable of any reference type(Walrus, Dog, array, etc.), Java allocates a box of 64 bits, **no matter what type of object**.

Then, when assign to a variable, its address is returned by the `new` operator.

For example:

```java
Walrus someWalrus;
someWalrus = new Walrus(1000, 8.3);
```

The first line creates a box of 64 bits.

The second line creates a new Walrus, and the address is returned by the `new` operator. These bits are then copied into the `someWalrus` box according to the GRoE.

![someWalrus_bit_notation](/assets/post_imgs/20180814_someWalrus_bit_notation.png)

##### Parameter Passing

When you pass parameters to a function, you are also simply copying the bits. In other words, the GRoE also applies to parameter passing. Copying the bits is usually called "pass the value". In Java, we **always** pass by value.

**Extra Reading**:
[The law of the Broken Futon](https://mathwithbaddrawings.com/2015/04/08/the-math-ceiling-wheres-your-cognitive-breaking-point/)



# IntLists

Arrays have a fixed size in Java that can never change. So we can build our own List.

We can build a simply IntList.

```java
public class IntList {
    public int first;
    public IntList rest;        

    public IntList(int f, IntList r) {
        first = f;
        rest = r;
    }
}
```
* ##### recursionSize and iterativeSize

```java
/** Return the size of the list using recursion! */
public int size() {
    if (rest == null) {
        return 1;
    }
    return 1 + this.rest.size();
}
```

:star: The key thing to remember about recursive code is that you need a **base case**. In this situation, the most reasonable base case is that rest is `null`, which results in a size 1 list.

```java
/** Return the size of the list using iterative! */
public int iterativeSize() {
    IntList p = this;
    int totalSize = 0;
    while (p != null) {
        totalSize += 1;
        p = p.rest;
    }
    return totalSize;
}
```

One thing to notice is that use the name `p` to remind yourself that the variable is holding a pointer. You need that pointer because you can't reassign **this** in Java.

##### get

Get the **ith** element of the list.

```java
/* Return the ith element of the IntList using recursion */
public int get(int i) {
    if (i == 0) {
        return first;
    }
    return rest.get(i - 1);
}

/* Return the ith element of the IntList using iterative */
public int iterativeGet(int i) {
    IntList p = this;
    while (i > 0) {
        p = p.rest;
        i -= 1;
    }
    return p.first;
}
```



# The SLList

`IntList` is awkward to use, so we build a new class `SLList`.

##### Rebranding and Bureaucracy

Renaming everything.

```java
public class IntNode {
    public int item;
    public IntNode next;

    public IntNode(int i, IntNode n) {
        item = i;
        next = n;
    }
}
```

Create a separate class called `SLList`

```java
public class SLList {
    public IntNode first;

    public SLList(int x) {
    	first = new IntNode(x, null);
    }
}
```

##### Eg. addFirst and getFirst

```java
/** Adds an item to the front of the list. */
public void addFirst(int x) {
    first = new IntNode(x, first);
}

/** Retrieves the front item from the list. */
public int getFirst() {
    return first.item;
}
```

The `SLList` class acts as a middleman between the list user and the the naked recursive data structure.

### Public vs.Private

A programmer can easily modify the list directly, which results in a malformed list with an infinite loop.

```java
SLList L = new SLList(15);
L.addFirst(10);
L.first.next.next = L.first.next;
```

To deal with this problem, we can modify the `first` variable which declared with the `private` keyword.

```java
public class SLList {
	private IntNode first;
...
}
```

**Private variables and methods can only be accessed by code inside the same `.java` file.**

### :star: recursive size()

The recursive call for `size` in `IntList` was straightforward `1 + this.rest.size()`.

However, `SLList` has no `rest` variable. So, we'll use middleman (a private helper method).

```java
/** Returns the size of the list starting at IntNode p. */
private static int size(IntNode p) {
    if (p.next == null) {
        return 1;
    }

    return 1 + size(p.next);
}

public int size() {
    return size(first);
}
```
Here, we have two methods, both named `size`. This is allowed in Java, since they have different parameters. They are **overloaded**.

**Extra Reading**: 
[Java's official document - Defining Methods](https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html)

:star: Two of the components of a method declaration comprise the *method signature*: **method's name** and **parameter types**

Naming a Method: **Verb** or **Begins with a verb in lowercase, followed by adjectives, nouns, etc.**
e.g. `run` `runFast` `getFinalData`

##### Caching

`size` method that is very slow for large lists is unacceptable. So we can add a `size` variable to the class that tracks the current size.

This practice of saving important data to speed up retrieval is sometimes known as **caching**.

```java
public class SLList {
    ... /* IntNode declaration omitted. */
    private IntNode first;
    private int size;

    public SLList(int x) {
        first = new IntNode(x, null);
        size = 1;
    }

    public void addFirst(int x) {
        first = new IntNode(x, first);
        size += 1;
    }

    public int size() {
        return size;
    }
    ...
}
```

### :star: Sentinel Nodes

Let's create an empty list. The most natural way is to set `first` to `null` if the list is empty.

```java
public SLList() {
    first = null;
    size = 0;
}
```

Unfortunately, this causes `addLast` method to crash if we insert into an empty list. Since `first` is `null`, `p.next` cause a null pointer exception.

```java
public void addLast(int x) {
    size += 1;
    IntNode p = first;
    while (p.next != null) {
        p = p.next;
    }

    p.next = new IntNode(x, null);
}
```

We can simply fix it by adding a special case, but it is ugly.

```java
public void addLast(int x) {
	if (first == null) {
		first = new IntNode(x, null);
		return;
	}
    size += 1;
    IntNode p = first;
    while (p.next != null) {
        p = p.next;
    }

    p.next = new IntNode(x, null);
}
```

The fundamental problem si the empty list has a null `first`, can't access `first.next`. So the cleaner solution is to make all `SLLists` are the "same", even if they are empty.

We can create a special node that is always there, which we will call a **sentinel node**.

```java
/** The first item (if it exists) is at sentinel.next */
private IntNode sentinel;

public void addLast(int x) {
    size += 1;
    IntNode p = sentinel;
    while (p.next != null) {
        p = p.next;
    }

    p.next = new IntNode(x, null);
}
```

##### Invariant

An invariant is a fact about a data structure that is guaranteed to be true (assuming there are no bugs in your code).

A `SLList` with sentinel node has at least the following invariants:

* The `sentinel` reference always points to a sentinel node.
* The first node (if exists), is always at `sentinel.next`.
* The `size` variable is always the total number of items that have been added.
